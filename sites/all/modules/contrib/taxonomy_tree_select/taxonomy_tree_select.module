<?php

/**
 * Implementation of hook_init().
 */
function taxonomy_tree_select_init() {
  if (module_exists('i18ntaxonomy')) {
    module_load_include('inc', 'taxonomy_tree_select', 'includes/taxonomy_tree_select.i18ntaxonomy.inc');
  }
}

/**
 * Implementation of hook_theme().
 */
function taxonomy_tree_select_theme($existing, $type, $theme, $path) {
  return array(
    'taxonomy_tree_select_nested_lists' => array(
      'arguments' => array('element' => NULL, 'tree' => NULL, 'parent' => NULL, 'tree_temp' => NULL),
    )
  );
}

/**
 * Implementation of hook_form_alter().
 */
function taxonomy_tree_select_form_taxonomy_form_vocabulary_alter(&$form, &$form_state) {
  // Work on vocabulary settings form
  if (!array_key_exists('#weight', $form['settings']['tags'])) {
    $form['settings']['tags']['#weight'] = -2;
  }
  $form['settings']['taxonomy_tree_select'] = array(
    '#type' => 'checkbox',
    '#title' => t('Tree select'),
    '#description' => t('On node form, shows a selectable tree with items of this vocabulary. (Incompatible with "Tags" option)'),
    '#weight' => $form['settings']['tags']['#weight'] + 1,
    '#default_value' => variable_get('vocabulary_' . $form['vid']['#value'] . '_tree_select', 0)
  );
}

/**
 * Implementation of hook_taxonomy().
 */
function taxonomy_tree_select_taxonomy($op, $type, $form_values) {
  if ($form_values['form_id'] == 'taxonomy_form_vocabulary') {
    $key = 'vocabulary_' . $form_values['vid'] . '_tree_select';
    switch ($op) {
      case 'insert':
      case 'update':
        $value = $form_values['taxonomy_tree_select'];
        if ($value) {
          variable_set($key, $value);
        }
        elseif (variable_get($key, 0)) {
          variable_del($key);
        }
        break;
      case 'delete':
        variable_del($key);
        break;
    }
  }
}

/**
 * Implementation of hook_form_alter().
 */
function taxonomy_tree_select_form_alter(&$form, &$form_state, $form_id) {
  // Work on node form...
  if ($form['#id'] == 'node-form' && $form['taxonomy']) {

    // Walk on all taxonomy fields
    foreach ($form['taxonomy'] as $key => $vocabulary) {
      $tree_select = variable_get('vocabulary_' . $key . '_tree_select', 0);

      // Check if is an tree select vocabulary
      if (is_array($vocabulary) && $tree_select) {

        // Replace select with radios or checkboxes
        $form['taxonomy'][$key] = _taxonomy_tree_select_individualize_selectbox($form['taxonomy'][$key]);

        // Apply theme to render field into nested lists
        $form['taxonomy'][$key]['#theme'] = 'taxonomy_tree_select_nested_lists';

        // Add external files
        $form['taxonomy'][$key]['#after_build'][] = '_taxonomy_tree_select_add_external_files';
      }
    }
  }
}

/**
 * Render terms in nested lists.
 *
 * @param $element
 *   A array with the form api element of taxonomy terms.
 *
 * @param $tree
 *   A array with the terms generated by taxonomy_get_tree().
 *
 * @param $parent
 *   A numeric value of the tid of the term from the tree should start.
 *   For internal use only.
 *
 * @param $tree_temp
 *   A array with temporary tree for internal use only.
 *
 * @return
 *   Rendered item list with the terms of the element
 */
function theme_taxonomy_tree_select_nested_lists($element, $tree = array(), $parent = 0, $tree_temp = array()) {
  global $theme;

  $vid = $element['#parents'][1];

  // When this function is called first time (not by herself), there's not $tree.
  if (!$tree) {
    $tree = taxonomy_get_tree($vid);
  }
  $list = $terms = array();

  foreach ($tree as $term) {
    if ($term->parents[0] == $parent) {

      $element[$term->tid]['#title'] = $term->name;

      drupal_alter('taxonomy_tree_select_term_element', $element[$term->tid], $term);

      $terms[$term->tid] = array(
        'data' => drupal_render($element[$term->tid])
      );
    }
    else {
      $tree_temp[$term->parents[0]][$term->tid] = $term;
    }
  }

  if (is_array($terms)) {
    foreach ($terms as $tid => &$term) {
      if (isset($tree_temp[$tid])) {
        $term['children'] = theme('taxonomy_tree_select_nested_lists', $element, $tree_temp[$tid], $tid, $tree_temp);

        $term['class'] = 'expansable expanded';
      }
      else {
        $term['class'] = 'leaf';
      }
    }
  }

  if ($parent) {
    return $terms;
  }
  else {
    // Option zero is the "none" option for radios boxes.
    if ($element[0]) {
      $list[0] = drupal_render($element[0]);
    }

    $tree_classes[] = 'taxonomy-tree';
    $tree_classes[] = sprintf('taxonomy-tree-theme-%s', $theme);

    // There's no user interface for this option, you can by enable it by
    // manually add an variable vocabulary_%vid_tree_select_show_input
    // with the value 0.
    if (!variable_get('vocabulary_' . $vid . '_tree_select_show_input', 1)) {
      $tree_classes[] = 'taxonomy-tree-hidden-input';
    }

    // Add terms to list to be printed
    $list = array_merge($list, $terms);

    return theme('item_list', $list, NULL, 'ul', array('class' => implode(' ', $tree_classes)));
  }
}

/**
 * Convert an select box element to a series of radio/checkboxes elements.
 *
 * @param $element
 *   A array with the form api element of type "select"
 *
 * @return
 *   Array with the form api element converted to type "radios" or "checkboxes"
 */
function _taxonomy_tree_select_individualize_selectbox($element) {
  if ($element['#type'] == 'select') {
    if ($element['#multiple']) {
      $element['#type'] = 'checkboxes';
    }
    else {
      $element['#type'] = 'radios';

      // Altough #default_value can always be an array even with non-multiple
      // select fields, it needs to be an string with radios fields
      if ($element['#default_value']) {
        $element['#default_value'] = array_shift($element['#default_value']);
      }
      else {
        $element['#default_value'] = '';
      }
    }
  }

  foreach ($element['#options'] as $key => &$option) {

    // Rewrite the options to be used with checkboxes/radios fapi types
    if (is_object($option)) {
      if (is_array($option->option)) {
        list($tid) = array_keys($option->option);
        $term_name  = $option->option[$tid];
      }
      $options[$tid] = $term_name;
    }

    // "None" option from non required vocabularies
    elseif (!$element['#multiple'] && !$key) {
      $options[0] = $option;
    }

    // Remove default options
    unset($element['#options'][$key]);
  }

  $element['#options'] = $options;

  // Remove select-only attributes
  unset(
    $element['#multiple'],
    $element['#size']
  );

  return $element;
}

/**
 * Add external files.
 *
 * This is done in a after build function to make sure this files will be
 * loaded even when the hook_form_alter doesn't run (i.e. in a form error).
 */
function _taxonomy_tree_select_add_external_files($form_element, $form_state) {
  drupal_add_css(drupal_get_path('module', 'taxonomy_tree_select') . '/taxonomy_tree_select.css');
  drupal_add_js(drupal_get_path('module', 'taxonomy_tree_select') . '/taxonomy_tree_select.js');

  return $form_element;
}
